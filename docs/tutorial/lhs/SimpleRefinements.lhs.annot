% Simple Refinement Types

Simple Refinement Types
-----------------------

\begin{code}
module SimpleRefinements where
import Prelude hiding ((!!), length)
import Language.Haskell.Liquid.Prelude
\end{code}


Simple Refinement Types
-----------------------

This type describes `Int` values that equal `0`.


\begin{code}
{-@ zero :: {v:Int | v = 0} @-}
zero     :: Int
zero     =  0
\end{code}

Refinements are *logical formulas*
----------------------------------

If 

- refinement of `T1` **implies** refinement of `T2` 

- `p1` **implies** `p2`

Then

- `T1` is a **subtype** of `T2`

- `{v:t | p1} <: {v:t | p2}`

Refinements are *logical formulas*
----------------------------------

For example, since

- `v = 0` *implies* `v >= 0`

Therefore
 
- `{v:Int | v = 0} <: {v:Int | v >= 0}`


Refinements are *logical formulas*
----------------------------------

\begin{code} So we can have a type for natural numbers:

type Nat = {v:Int | v >= 0}
\end{code}

<br>

And we can type `0` as `Nat`:

<br>

\begin{code}
{-@ zero' :: Nat @-}
zero'     :: Int
zero'     =  0
\end{code}

Refinements are *logical formulas*
----------------------------------

Similarly, since

- `v = 0 => v mod 2 = 0` 

Therefore

- `{v:Int | v = 0} <: {v:Int | v mod 2 = 0}`

Thus, via SMT based subtyping LiquidHaskell verifies:

\begin{code}
{-@ type Even = {v:Int | v mod 2 = 0} @-}

{-@ zero'' :: Even @-}
zero''     :: Int
zero''     =  0
\end{code}


Lists
-----

Refinements can live *inside* type constructors:

\begin{code}
infixr `C`
data L a = N | C a (L a)
\end{code}

Lists: Universal Invariants 
---------------------------

Constructors enable *universally quantified* invariants.

For example, *every element* in a list is non-negative:

\begin{code}
{-@ natList :: L Nat @-}
natList     :: L Int
natList     =  0 `C` 1 `C` 3 `C` N
\end{code}

or, *every element* in a list is even:

\begin{code}
{-@ evenList :: L Even @-}
evenList     :: L Int
evenList     =  0 `C` 2 `C` 8 `C` N
\end{code}


Refinement Function Types
-------------------------

Consider a `safeDiv` operator: <br>

\begin{code}
safeDiv    :: Int -> Int -> Int
safeDiv x y = x `div` y
\end{code}

We can use refinements to specify a **precondition**: divisor is **non-zero** <br>

\begin{code}
{-@ safeDiv :: Int -> {v:Int | v != 0} -> Int @-}
\end{code}

<br>

Demo

Dependent Function Types
------------------------

\begin{code} Consider a list indexing function:
(!!)         :: L a -> Int -> a
(C x _) !! 0 = x
(C _ xs)!! n = xs!!(n-1)
_       !! _ = liquidError "This should not happen!"
\end{code}

<br>

We desire **precondition** that index `i` be between `0` and **list length**

Measuring A List's length in logic
----------------------------------

We define a **measure** for the length of a `List` <br>

\begin{code}
{-@ measure llen :: (L a) -> Int
    llen(N)      = 0
    llen(C x xs) = 1 + (llen xs)
  @-}
\end{code}

<br>

\begin{code} The measure strengthens the type of data constructors
data L a where 
  N :: {v : L a | (llen v) = 0}
  C :: a -> xs:(L a) -> {v:(L a) |(llen v) = 1 + (llen xs)}
\end{code}

Measuring A List's length in logic
----------------------------------

Now we can verify

<br>

\begin{code}
{-@ length :: xs:(L a) -> {v:Int | v = (llen xs)} @-}
length     :: L a -> Int
length N        = 0
length (C _ xs) = 1 + (length xs)
\end{code}

Measuring A List's length in logic
----------------------------------

And we can type `(!!)` as

<br>

\begin{code}
{-@ (!!) :: ls:(L a) -> {v:Nat | true} -> a @-}
(!!)         :: L a -> Int -> a
(C x _) !! 0 = x
(C _ xs)!! n = xs!!(n-1)
_       !! _ = liquidError "This should not happen!"
\end{code}

Demo: lets see what happens if we **remove** the precondition


SimpleRefinements.!!
204
9
2
forall a.
(SimpleRefinements.L a) -> {VV : (GHC.Types.Int) | (VV >= 0)} -> a


GHC.Types.I#
190
19
1
x:(GHC.Prim.Int#) -> {VV : (GHC.Types.Int) | (VV == (x  :  int))}


unknown
205
22
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x - y))}


GHC.Types.I#
90
15
1
x:(GHC.Prim.Int#) -> {VV : (GHC.Types.Int) | (VV == (x  :  int))}


GHC.Types.I#
69
14
1
x:(GHC.Prim.Int#) -> {VV : (GHC.Types.Int) | (VV == (x  :  int))}


unknown
122
31
3
{VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)}) | ((llen VV) == (1 + (llen xs)))}


x
133
15
1
{VV : (GHC.Types.Int) | (VV == x)}


lq_anf__d1eV
205
23
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


lq_anf__d1eJ
114
22
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


SimpleRefinements.length
190
1
3
forall a.
xs:(SimpleRefinements.L a)
-> {VV : (GHC.Types.Int) | (VV == (llen xs))}


lq_anf__d1eE
122
29
1
{VV : (GHC.Types.Int) | (VV == (8  :  int))}


unknown
206
16
1
{VV : [(GHC.Types.Char)] | false} -> {VV : a | false}


ds_d1ep
205
21
1
{VV : (GHC.Types.Int) | (VV >= 0)}


lq_anf__d1eP
191
19
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


unknown
205
18
1
(SimpleRefinements.L a) -> {VV : (GHC.Types.Int) | (VV >= 0)} -> a


y
133
11
1
{VV : (GHC.Types.Int) | (VV /= 0)}


unknown
114
18
3
{VV : (GHC.Types.Int) | (VV >= 0) && (VV >= zero)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | (VV >= 0) && (VV >= zero)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | (VV >= 0) && (VV >= zero)}) | ((llen VV) == (1 + (llen xs)))}


lq_anf__d1eL
114
34
1
{VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | false}) | ((llen VV) == 0)}


unknown
191
21
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x + y))}


GHC.Types.I#
22
13
1
x:(GHC.Prim.Int#) -> {VV : (GHC.Types.Int) | (VV == (x  :  int))}


ds_d1eq
205
16
1
(SimpleRefinements.L a)


SimpleRefinements.natList
114
1
1
(SimpleRefinements.L {VV : (GHC.Types.Int) | (VV >= 0)})


unknown
122
25
3
{VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV /= 0) && (VV > 0) && (VV > zero) && (VV >= 0)}) | ((llen VV) == (1 + (llen xs)))}


x
133
9
1
(GHC.Types.Int)


lq_anf__d1eI
114
16
1
{VV : (GHC.Types.Int) | (VV == (0  :  int))}


lq_anf__d1eD
122
23
1
{VV : (GHC.Types.Int) | (VV == (2  :  int))}


unknown
191
24
2
xs:(SimpleRefinements.L a)
-> {VV : (GHC.Types.Int) | (VV == (llen xs))}


x
204
16
1
{VV : a | (VV == x)}


y
133
23
1
{VV : (GHC.Types.Int) | (VV == y) && (VV /= 0)}


unknown
114
30
3
{VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)}) | ((llen VV) == (1 + (llen xs)))}


SimpleRefinements.zero
22
1
1
{VV : (GHC.Types.Int) | (VV == 0)}


lq_anf__d1eK
114
28
1
{VV : (GHC.Types.Int) | (VV == (3  :  int))}


lq_anf__d1eF
122
35
1
{VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | false}) | ((llen VV) == 0)}


unknown
122
19
3
{VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV >= 0) && (VV >= zero)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV >= 0) && (VV >= zero)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0) && (VV >= 0) && (VV >= zero)}) | ((llen VV) == (1 + (llen xs)))}


SimpleRefinements.zero''
90
1
1
{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}


lq_anf__d1eC
122
17
1
{VV : (GHC.Types.Int) | (VV == (0  :  int))}


SimpleRefinements.evenList
122
1
1
(SimpleRefinements.L {VV : (GHC.Types.Int) | ((VV mod 2) == 0)})


lq_anf__d1eS
206
28
1
{VV : [(GHC.Types.Char)] | ((len VV) >= 0)}


SimpleRefinements.safeDiv
133
1
2
(GHC.Types.Int)
-> {VV : (GHC.Types.Int) | (VV /= 0)} -> (GHC.Types.Int)


unknown
133
17
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x / y))}


unknown
114
24
3
{VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)}
-> xs:(SimpleRefinements.L {VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)})
-> {VV : (SimpleRefinements.L {VV : (GHC.Types.Int) | (VV /= 0) && (VV /= zero'') && (VV > 0) && (VV > zero) && (VV >= 0)}) | ((llen VV) == (1 + (llen xs)))}


SimpleRefinements.zero'
69
1
1
{VV : (GHC.Types.Int) | (VV >= 0)}


xs
191
31
1
{VV : (SimpleRefinements.L a) | (VV == xs)}


 
206
28
0
206
53



