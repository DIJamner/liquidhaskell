% Abstract Refinements

Abstract Refinements
--------------------

\begin{code}
module AbstractRefinements where
\end{code}


Abstract Refinements
--------------------

<br>

\begin{code} Consider the following function 
maxInt     :: Int -> Int -> Int 
maxInt x y = if x <= y then y else x 
\end{code}

<br>

\begin{code} We can give `maxInt` many (incomparable) refinement types:

maxInt :: Nat -> Nat -> Nat

maxInt :: Even -> Even -> Even

maxInt :: Prime -> Prime -> Prime
\end{code}

But **which** is the **right** type?


Parametric Invariants 
---------------------

`maxInt` returns *one of* its two inputs `x` and `y`. 

- **If** *both inputs* satisfy a property  

- **Then** *output* must satisfy that property

This holds, **regardless of what that property was!**
 
- That  is, we can **abstract over refinements**

- Or,  **parameterize** a type over its refinements.

Parametric Invariants 
--------------------- 

We type `maxInt` as <br> 

\begin{code}
{-@ maxInt :: forall <p :: Int -> Prop>. 
                Int<p> -> Int<p> -> Int<p> @-}
maxInt     :: Int -> Int -> Int 
maxInt x y = if x <= y then y else x 
\end{code}

<br>

This type states explicitly:

- **For any property** `p`, that is a property of `Int`, 

- `maxInt` takes two **inputs** of which satisfy `p`,

- `maxInt` returns an **output** that satisfies `p`. 

Parametric Invariants via Abstract Refinements
----------------------------------------------

We call `p` an an **abstract refinement** <br>

\begin{code} ... 
maxInt :: forall <p :: Int -> Prop>. Int<p> -> Int<p> -> Int<p> 
\end{code}

<br>

In the refinement logic,

- abstract refinements are **uninterpreted function symbols**

- which (only) satisfy the *congruence axiom*: forall x, y. x = y => (p x) = (p y)

Thus, intuitively 

- `Int<p>` is just an abbreviation for `{v:Int | (p v)}`


Using Abstract Refinements
--------------------------

- **If** we call `maxInt` with two `Int`s with the same concrete refinement,

- **Then** the `p` will be instantiated with that concrete refinement,

- **The output** of the call will also enjoy the concrete refinement.

For example, the refinement is instantiated with `\v -> v >= 0` <br>

\begin{code}
{-@ maxNat :: Nat @-}
maxNat     :: Int
maxNat     = maxInt 2 5
\end{code}

Using Abstract Refinements
--------------------------

- **If** we call `maxInt` with two `Int`s with the same concrete refinement,

- **Then** the `p` will be instantiated with that concrete refinement,

- **The output** of the call will also enjoy the concrete refinement.

Or any other property <br>

\begin{code}
{-@ type RGB = {v: Int | ((0 <= v) && (v < 256)) } @-}
\end{code}

<br> to verify <br>

\begin{code}
{-@ maxRGB :: RGB @-}
maxRGB     :: Int
maxRGB     = maxInt 56 8
\end{code}


lq_anf__dkz
131
21
1
{VV : (GHC.Types.Int) | (VV == (56  :  int))}


y
59
29
1
{VV : (GHC.Types.Int) | ((papp1 p VV)) && (VV == y)}


x
59
8
1
{VV : (GHC.Types.Int) | ((papp1 p VV))}


AbstractRefinements.maxRGB
131
1
1
{VV : (GHC.Types.Int) | (VV < 256) && (0 <= VV)}


y
59
10
1
{VV : (GHC.Types.Int) | ((papp1 p VV))}


unknown
108
14
4
forall <p :: (GHC.Types.Int)-> Bool>.
{VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}


AbstractRefinements.maxNat
108
1
1
{VV : (GHC.Types.Int) | (VV >= 0)}


x
59
36
1
{VV : (GHC.Types.Int) | ((papp1 p VV)) && (VV == x)}


unknown
131
14
4
forall <p :: (GHC.Types.Int)-> Bool>.
{VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}


y
59
22
1
{VV : (GHC.Types.Int) | ((papp1 p VV)) && (VV == y)}


lq_anf__dkx
108
21
1
{VV : (GHC.Types.Int) | (VV == (2  :  int))}


lq_anf__dkA
131
24
1
{VV : (GHC.Types.Int) | (VV == (8  :  int))}


AbstractRefinements.maxInt
59
1
4
forall <p :: (GHC.Types.Int)-> Bool>.
{VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}
-> {VV : (GHC.Types.Int)<p> | true}


x
59
17
1
{VV : (GHC.Types.Int) | ((papp1 p VV)) && (VV == x)}


lq_anf__dky
108
23
1
{VV : (GHC.Types.Int) | (VV == (5  :  int))}


unknown
59
19
3
x:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-> y:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> (x <= y))}


