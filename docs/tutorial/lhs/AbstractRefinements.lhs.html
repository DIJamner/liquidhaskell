<h2 id="abstract-refinements">Abstract Refinements</h2>
<pre><span class=hs-linenum>7: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>AbstractRefinements</span> <span class='hs-keyword'>where</span>
</pre>


<h2 id="abstract-refinements-1">Abstract Refinements</h2>
<p><br></p>
Consider the following function
<pre><span class=hs-linenum>17: </span><span class='hs-definition'>maxInt</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>18: </span><span class='hs-definition'>maxInt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>x</span> 
</pre>

<p><br></p>
We can give <code>maxInt</code> many (incomparable) refinement types:
<pre><span class=hs-linenum>24: </span>
<span class=hs-linenum>25: </span><span class='hs-definition'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span>
<span class=hs-linenum>26: </span>
<span class=hs-linenum>27: </span><span class='hs-definition'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Even</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Even</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Even</span>
<span class=hs-linenum>28: </span>
<span class=hs-linenum>29: </span><span class='hs-definition'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Prime</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Prime</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Prime</span>
</pre>

<p>But <strong>which</strong> is the <strong>right</strong> type?</p>
<h2 id="parametric-invariants">Parametric Invariants</h2>
<p><code>maxInt</code> returns <em>one of</em> its two inputs <code>x</code> and <code>y</code>.</p>
<ul>
<li><p><strong>If</strong> <em>both inputs</em> satisfy a property</p></li>
<li><p><strong>Then</strong> <em>output</em> must satisfy that property</p></li>
</ul>
<p>This holds, <strong>regardless of what that property was!</strong></p>
<ul>
<li><p>That is, we can <strong>abstract over refinements</strong></p></li>
<li><p>Or, <strong>parameterize</strong> a type over its refinements.</p></li>
</ul>
<h2 id="parametric-invariants-1">Parametric Invariants</h2>
<p>We type <code>maxInt</code> as <br></p>
<pre><span class=hs-linenum>56: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Prop</span><span class='hs-varop'>&gt;.</span> 
<span class=hs-linenum>57: </span>                <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>58: </span><span class='hs-definition'>maxInt</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>59: </span><a class=annot href="#"><span class=annottext>forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class='hs-definition'>maxInt</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV))}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV))}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-&gt; y:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}</span><span class='hs-varop'>&lt;=</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class='hs-varid'>y</span></a> <span class='hs-keyword'>then</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class='hs-varid'>y</span></a> <span class='hs-keyword'>else</span> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class='hs-varid'>x</span></a> 
</pre>

<p><br></p>
<p>This type states explicitly:</p>
<ul>
<li><p><strong>For any property</strong> <code>p</code>, that is a property of <code>Int</code>,</p></li>
<li><p><code>maxInt</code> takes two <strong>inputs</strong> of which satisfy <code>p</code>,</p></li>
<li><p><code>maxInt</code> returns an <strong>output</strong> that satisfies <code>p</code>.</p></li>
</ul>
<h2 id="parametric-invariants-via-abstract-refinements">Parametric Invariants via Abstract Refinements</h2>
<p>We call <code>p</code> an an <strong>abstract refinement</strong> <br></p>
...
<pre><span class=hs-linenum>78: </span><span class='hs-definition'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Prop</span><span class='hs-varop'>&gt;.</span> <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-varop'>&lt;</span><span class='hs-varid'>p</span><span class='hs-varop'>&gt;</span> 
</pre>

<p><br></p>
<p>In the refinement logic,</p>
<ul>
<li><p>abstract refinements are <strong>uninterpreted function symbols</strong></p></li>
<li><p>which (only) satisfy the <em>congruence axiom</em>: forall x, y. x = y =&gt; (p x) = (p y)</p></li>
</ul>
<p>Thus, intuitively</p>
<ul>
<li><code>Int&lt;p&gt;</code> is just an abbreviation for <code>{v:Int | (p v)}</code></li>
</ul>
<h2 id="using-abstract-refinements">Using Abstract Refinements</h2>
<ul>
<li><p><strong>If</strong> we call <code>maxInt</code> with two <code>Int</code>s with the same concrete refinement,</p></li>
<li><p><strong>Then</strong> the <code>p</code> will be instantiated with that concrete refinement,</p></li>
<li><p><strong>The output</strong> of the call will also enjoy the concrete refinement.</p></li>
</ul>
<p>For example, the refinement is instantiated with <code>\v -&gt; v &gt;= 0</code> <br></p>
<pre><span class=hs-linenum>106: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>maxNat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>107: </span><span class='hs-definition'>maxNat</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>108: </span><a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV &gt;= 0)}</span><span class='hs-definition'>maxNat</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class='hs-varid'>maxInt</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV == (2  :  int))}</span><span class='hs-num'>2</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV == (5  :  int))}</span><span class='hs-num'>5</span></a>
</pre>

<h2 id="using-abstract-refinements-1">Using Abstract Refinements</h2>
<ul>
<li><p><strong>If</strong> we call <code>maxInt</code> with two <code>Int</code>s with the same concrete refinement,</p></li>
<li><p><strong>Then</strong> the <code>p</code> will be instantiated with that concrete refinement,</p></li>
<li><p><strong>The output</strong> of the call will also enjoy the concrete refinement.</p></li>
</ul>
<p>Or any other property <br></p>
<pre><span class=hs-linenum>123: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>RGB</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-num'>0</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>256</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>

<p><br> to verify <br></p>
<pre><span class=hs-linenum>129: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>maxRGB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RGB</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>130: </span><span class='hs-definition'>maxRGB</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>131: </span><a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class='hs-definition'>maxRGB</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class='hs-varid'>maxInt</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV == (56  :  int))}</span><span class='hs-num'>56</span></a> <a class=annot href="#"><span class=annottext>{VV : (GHC.Types.Int) | (VV == (8  :  int))}</span><span class='hs-num'>8</span></a>
</pre>


<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>
