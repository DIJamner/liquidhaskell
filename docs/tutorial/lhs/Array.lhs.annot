\begin{code}
module LiquidArray where

import Language.Haskell.Liquid.Prelude (liquidAssume)
\end{code}

Indexed-Dependent Refinements
=============================

We illustrate how to use abstract refinements to talk about 
indexed-dependent invariants.

We use a Vector of `a`s implemented as a function from `Int` to `a`s

\begin{code}
data Vec a = V (Int -> a)
\end{code}

We abstract over the `dom` that describes the domain
and `rng` that describes the value with respect to its index.

\begin{code}
{-@
data Vec a <dom :: Int -> Prop, rng :: Int -> a -> Prop>
     = V {a :: i:Int<dom> -> a <rng i>}
  @-}
\end{code}

With this we can describe interesting vectors:

A vector of `Int` defined on values less than `100`
containing values equal to their index:
\begin{code}
{-@ type IdVec = 
     Vec <{\v -> (v < 100)}, {\j v -> (v = j)}> Int
  @-}
\end{code}

A vector defined on the range `[0..n)` with its last element equal to `0`:
\begin{code}
{-@ type ZeroTerm N = 
     Vec <{\v -> (0 <= v && v < N)}, {\j v -> (j = N - 1 => v = 0)}> Int
  @-}
\end{code}

Or a vector defined on integers whose value at index `i` is either 
`0` or the `i`th fibonacci:
\begin{code}
{-@ measure fib :: Int -> Int @-}
{-@ type FibV = 
     Vec <{\v -> 0=0}, {\j v -> ((v != 0) => (v = fib(j)))}> Int @-}
\end{code}


Operations on Vectors
---------------------

As a next step we give appropriate types to vector operations:


`empty` returns a Vector whose domain is always false:
\begin{code}
{-@ empty :: forall <p :: Int -> a -> Prop>. Vec <{\v -> 0=1}, p> a @-}
empty     :: Vec  a
empty     = V $ \_ -> (error "Empty array!")
\end{code}

If we `get` the `i`th element of an array, 
the result should satisfy the range at `i`:
\begin{code} 
{-@ get :: forall a <r :: Int -> a -> Prop, d :: Int -> Prop>.
             i: Int<d> ->
             a: Vec<d, r> a ->
             a<r i> @-}
get :: Int -> Vec a -> a
get i (V f) = f i
\end{code}

Finally, if we `set` the `i`th element of a Vector to a value
that satisfies range at `i`, 
then Vector's domain will be extended with `i`:
\begin{code}
{-@ set :: forall a <r :: Int -> a -> Prop, d :: Int -> Prop>.
      i: Int<d> ->
      x: a<r i> ->
      a: Vec <{v:Int<d> | v != i}, r> a -> 
      Vec <d, r> a @-}
set :: Int -> a -> Vec a -> Vec a
set i v (V f) = V $ \k -> if k == i then v else f k
\end{code}

Using Vectors
-------------

In the following example, we use the previous Vector operations
to efficiently compute the `i`th fibonacci number:

\begin{code}
{-@ assume axiom_fib :: i:Int -> {v: Bool | (Prop(v) <=> (fib(i) = ((i <= 1) ? 1 : ((fib(i-1)) + (fib(i-2)))))) } @-}
axiom_fib :: Int -> Bool
axiom_fib i = undefined

{-@ fastFib :: x:Int -> {v:Int | v = fib(x)} @-}
fastFib     :: Int -> Int
fastFib n   = snd $ fibMemo (V (\_ -> 0)) n


{-@ fibMemo :: FibV -> i:Int -> (FibV, {v: Int | v = fib(i)}) @-}
fibMemo :: Vec Int -> Int -> (Vec Int, Int)
fibMemo t i 
  | i <= 1    
  = (t, liquidAssume (axiom_fib i) (1 :: Int))
  
  | otherwise 
  = case get i t of   
      0 -> let (t1, n1) = fibMemo t  (i-1)
               (t2, n2) = fibMemo t1 (i-2)
               n        = liquidAssume (axiom_fib i) (n1 + n2)
           in  (set i n t2,  n)
      n -> (t, n)
\end{code}


unknown
118
27
2
b:(GHC.Types.Bool)
-> (GHC.Types.Int) -> {VV : (GHC.Types.Int) | ((Prop b))}


t1
116
17
1
{VV : (LiquidArray.Vec <True, \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)) | (VV == t1)}


k
89
51
1
{VV : (GHC.Types.Int) | ((papp1 d VV)) && (VV == k)}


GHC.Err.undefined
101
15
1
forall a. a


i
89
35
1
{VV : (GHC.Types.Int) | ((papp1 d VV)) && (VV == i)}


unknown
89
19
6
((x4:{VV : (GHC.Types.Int) | ((papp1 d VV))}
  -> {VV : a | ((papp2 r VV x4))})
 -> (LiquidArray.Vec <((papp1 d VV)), \x2 VV -> ((papp2 r VV x2))> a))
-> (x4:{VV : (GHC.Types.Int) | ((papp1 d VV))}
    -> {VV : a | ((papp2 r VV x4))})
-> (LiquidArray.Vec <((papp1 d VV)), \x2 VV -> ((papp2 r VV x2))> a)


unknown
118
58
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x + y))}


t2
119
25
1
{VV : (LiquidArray.Vec <(VV /= i), \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)) | (VV == t2) && (VV == t2)}


unknown
105
19
4
(((LiquidArray.Vec <false, \x2 VV -> ((VV /= 0) => (VV == (fib x2)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib n))})
 -> {VV : (GHC.Types.Int) | (VV == (fib n))})
-> ((LiquidArray.Vec <false, \x2 VV -> ((VV /= 0) => (VV == (fib x2)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib n))})
-> {VV : (GHC.Types.Int) | (VV == (fib n))}


unknown
89
32
3
x:{VV : (GHC.Types.Int) | ((papp1 d VV))}
-> y:{VV : (GHC.Types.Int) | ((papp1 d VV))}
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> (x == y))}


t
116
35
1
{VV : (LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)) | (VV == t)}


unknown
118
41
2
i:(GHC.Types.Int)
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> ((fib i) == (if (i <= 1) then 1 else ((fib (i - 1)) + (fib (i - 2))))))}


LiquidArray.fibMemo
110
1
3
(LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int))
-> i:(GHC.Types.Int)
-> ((LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib i))})


unknown
65
24
1
[(GHC.Types.Char)] -> {VV : a | false}


unknown
89
49
2
i:{VV : (GHC.Types.Int) | ((papp1 d VV)) && (VV /= i)}
-> {VV : a | ((papp2 r VV i))}


lq_anf__d1fO
89
17
3
(i:{VV : (GHC.Types.Int) | ((papp1 d VV))}
 -> {VV : a | ((papp2 r VV i))})
-> (LiquidArray.Vec <((papp1 d VV)), \x1 VV -> ((papp2 r VV x1))> a)


LiquidArray.set
89
1
5
forall a <r :: (GHC.Types.Int)-> a-> Bool, d :: (GHC.Types.Int)-> Bool>.
i:{VV : (GHC.Types.Int)<d> | true}
-> {VV : a<r i> | true}
-> (LiquidArray.Vec <d & (VV /= i), \_ VV -> r> a)
-> (LiquidArray.Vec <d, \_ VV -> r> a)


LiquidArray.fastFib
105
1
1
x:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (fib x))}


lq_anf__d1gg
105
33
1
(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (0  :  int))}


t
115
16
1
{VV : (LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)) | (VV == t)}


k
89
22
1
{VV : (GHC.Types.Int) | ((papp1 d VV))}


n1
116
21
1
{VV : (GHC.Types.Int) | (VV == n1)}


unknown
112
9
3
b:(GHC.Types.Bool)
-> {VV : (GHC.Types.Int) | (VV == 1) && (VV > 0) && (VV >= i)}
-> {VV : (GHC.Types.Int) | ((Prop b)) && (VV == 1) && (VV > 0) && (VV >= i)}


lq_anf__d1fL
65
30
1
{VV : [(GHC.Types.Char)] | ((len VV) >= 0)}


i
101
11
1
(GHC.Types.Int)


v
89
7
1
{VV : a | ((papp2 r VV i))}


ds_d1fA
120
16
1
{VV : (GHC.Types.Int) | ((VV /= 0) => (VV == (fib i)))}


i
111
5
1
{VV : (GHC.Types.Int) | (VV == i)}


unknown
117
27
3
(LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int))
-> i:(GHC.Types.Int)
-> ((LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib i))})


unknown
105
39
1
{VV : (GHC.Types.Int) | (VV == (0  :  int))}


unknown
65
15
4
(({VV : (GHC.Types.Int) | false} -> {VV : a | false})
 -> (LiquidArray.Vec <false, \_ VV -> false> {VV : a | false}))
-> ({VV : (GHC.Types.Int) | false} -> {VV : a | false})
-> (LiquidArray.Vec <false, \_ VV -> false> {VV : a | false})


i
116
39
1
{VV : (GHC.Types.Int) | (VV == i)}


unknown
76
15
2
i:{VV : (GHC.Types.Int) | ((papp1 d VV))}
-> {VV : a | ((papp2 r VV i))}


n
119
30
1
{VV : (GHC.Types.Int) | (VV == n)}


unknown
117
40
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x - y))}


lq_anf__d1fR
89
21
2
k:{VV : (GHC.Types.Int) | ((papp1 d VV))}
-> {VV : a | ((papp2 r VV k))}


i
89
5
1
{VV : (GHC.Types.Int) | ((papp1 d VV))}


unknown
111
7
3
x:(GHC.Types.Int)
-> y:(GHC.Types.Int)
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> (x <= y))}


n2
118
60
1
{VV : (GHC.Types.Int) | (VV == n2) && (VV == n2)}


unknown
105
21
3
(LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int))
-> i:(GHC.Types.Int)
-> ((LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib i))})


lq_anf__d1fK
65
13
2
({VV : (GHC.Types.Int) | false} -> {VV : a | false})
-> (LiquidArray.Vec <false, \_ VV -> false> {VV : a | false})


lq_anf__d1g3
117
41
1
{VV : (GHC.Types.Int) | (VV == (2  :  int))}


v
89
42
1
{VV : a | ((papp2 r VV i)) && (VV == v)}


t
120
13
1
{VV : (LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)) | (VV == t)}


lq_anf__d1fX
116
41
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


i
118
51
1
{VV : (GHC.Types.Int) | (VV == i)}


lq_anf__d1gd
112
37
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


LiquidArray.get
76
1
3
forall a <r :: (GHC.Types.Int)-> a-> Bool, d :: (GHC.Types.Int)-> Bool>.
i:{VV : (GHC.Types.Int)<d> | true}
-> (LiquidArray.Vec <d, \_ VV -> r> a) -> {VV : a<r i> | true}


GHC.Tuple.(,)
119
16
2
forall a b <p2 :: a-> b-> Bool>.
x1_(,):a -> {VV : b<p2 x1_(,)> | true} -> (a, b)<p2>


GHC.Tuple.(,)
112
5
2
forall a b <p2 :: a-> b-> Bool>.
x1_(,):a -> {VV : b<p2 x1_(,)> | true} -> (a, b)<p2>


i
76
17
1
{VV : (GHC.Types.Int) | ((papp1 d VV)) && (VV == i)}


i
110
11
1
(GHC.Types.Int)


unknown
120
12
1
({VV : (LiquidArray.Vec <True, \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)) | (VV == t)}, {VV : (GHC.Types.Int) | (VV == (fib i)) && (VV /= 0)})<\_ VV -> (VV == (fib i)) && (VV /= 0)>


unknown
116
40
2
x:(GHC.Types.Int)
-> y:(GHC.Types.Int) -> {VV : (GHC.Types.Int) | (VV == (x - y))}


unknown
119
17
5
forall <d :: (GHC.Types.Int)-> Bool, r :: (GHC.Types.Int)-> (GHC.Types.Int)-> Bool>.
i:{VV : (GHC.Types.Int)<d> | true}
-> {VV : (GHC.Types.Int)<r i> | true}
-> (LiquidArray.Vec <d & (VV /= i), \_ VV -> r> (GHC.Types.Int))
-> (LiquidArray.Vec <d, \_ VV -> r> (GHC.Types.Int))


n
105
43
1
{VV : (GHC.Types.Int) | (VV == n)}


i
117
39
1
{VV : (GHC.Types.Int) | (VV == i)}


i
115
14
1
{VV : (GHC.Types.Int) | (VV == i)}


lq_anf__d1fS
111
10
1
{VV : (GHC.Types.Int) | (VV == (1  :  int))}


unknown
116
27
3
(LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int))
-> i:(GHC.Types.Int)
-> ((LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib i))})


unknown
112
23
2
i:(GHC.Types.Int)
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> ((fib i) == (if (i <= 1) then 1 else ((fib (i - 1)) + (fib (i - 2))))))}


t
110
9
1
(LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int))


n
118
16
1
(GHC.Types.Int)


t
112
6
1
{VV : (LiquidArray.Vec <True, \j VV -> ((VV /= 0) => (VV == (fib j)))> (GHC.Types.Int)) | (VV == t)}


n
105
9
1
(GHC.Types.Int)


n2
117
21
1
{VV : (GHC.Types.Int) | (VV == n2)}


lq_anf__d1fM
65
17
1
{VV : (GHC.Types.Int) | false} -> {VV : a | false}


LiquidArray.empty
65
1
2
forall a <p :: (GHC.Types.Int)-> a-> Bool>.
(LiquidArray.Vec <false, \_ VV -> p> a)


k
89
30
1
{VV : (GHC.Types.Int) | ((papp1 d VV)) && (VV == k)}


n1
118
55
1
{VV : (GHC.Types.Int) | (VV == n1) && (VV == n1)}


i
112
33
1
{VV : (GHC.Types.Int) | (VV == i)}


i
76
5
1
{VV : (GHC.Types.Int) | ((papp1 d VV))}


unknown
105
30
4
forall <rng :: (GHC.Types.Int)-> (GHC.Types.Int)-> Bool, dom :: (GHC.Types.Int)-> Bool>.
(i:{VV : (GHC.Types.Int)<dom> | true}
 -> {VV : (GHC.Types.Int)<rng i> | ((VV /= 0) => (VV == (fib $$"Empty array!"))) && ((VV /= 0) => (VV == (fib n))) && (VV == 0)})
-> (LiquidArray.Vec <dom, rng> {VV : (GHC.Types.Int) | ((VV /= 0) => (VV == (fib $$"Empty array!"))) && ((VV /= 0) => (VV == (fib n))) && (VV == 0)})


i
119
21
1
{VV : (GHC.Types.Int) | (VV == i)}


lq_anf__d1gf
105
15
2
((LiquidArray.Vec <false, \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)), {VV : (GHC.Types.Int) | (VV == (fib n))})
-> {VV : (GHC.Types.Int) | (VV == (fib n))}


t1
117
35
1
{VV : (LiquidArray.Vec <True, \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)) | (VV == t1) && (VV == t1)}


unknown
115
10
4
forall <d :: (GHC.Types.Int)-> Bool, r :: (GHC.Types.Int)-> (GHC.Types.Int)-> Bool>.
i:{VV : (GHC.Types.Int)<d> | true}
-> (LiquidArray.Vec <d, \_ VV -> r> (GHC.Types.Int))
-> {VV : (GHC.Types.Int)<r i> | true}


LiquidArray.axiom_fib
101
1
2
i:(GHC.Types.Int)
-> {VV : (GHC.Types.Bool) | (((Prop VV)) <=> ((fib i) == (if (i <= 1) then 1 else ((fib (i - 1)) + (fib (i - 2))))))}


n
119
23
1
{VV : (GHC.Types.Int) | (VV == n)}


t2
117
17
1
{VV : (LiquidArray.Vec <(VV /= i), \x1 VV -> ((VV /= 0) => (VV == (fib x1)))> (GHC.Types.Int)) | (VV == t2)}


