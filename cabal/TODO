TODO
----

Failed 5 tests: pos/bar.hs, pos/meas3.hs, pos/meas4.hs, pos/meas5.hs, pos/meas6.hs


GHC.List.lhs <---------- HEREHEREHEREHERE

34, 35 (first arg for length)   TOP

72, 73  (first arg for rev)     TOP

75, 76 (second arg for rev)     BOT ????

75 (pred-ref)
76 (param-ref)

86 <: 75
97 <: 75

87 <: 76
96 <: 76

73 -> 94
   -> 92


../benchmarks/ghc-7.4.1/List.lhs:115:1-4
{-@ assert null :: forall a. xs:[a] -> {v: Bool | ((? v) <=> len(xs) = 0) }  @-}


../benchmarks/ghc-7.4.1/List.lhs:296:1-9
{-@ assert takeWhile    :: forall a. (a -> Bool) -> xs:[a] -> {v: [a] | len(v) <= len(xs)} @-}


../benchmarks/ghc-7.4.1/List.lhs:400:1-4
{-@ assert take        :: forall a. n: Int -> xs:[a] -> {v:[a] | len(v) = ((len(xs) < n) ? len(xs) : n) } @-}


../benchmarks/ghc-7.4.1/List.lhs:430:1-4
{-@ assert drop        :: forall a. n: Int -> xs:[a] -> {v:[a] | len(v) = ((len(xs) <  n) ? 0 : len(xs) - n) } @-}

../benchmarks/ghc-7.4.1/List.lhs:496:1-7


FEATURES 
--------

- Add/Parse predicate signatures for lists<p> and tuples<p>: [{x: Int | x > 0}]  
- pos/deptup.hs (type signature: for constructor wrapper)




foldl f b []     = b
foldl f b (x:xs) = foldl f (f b x) xs

foldl (\b x -> b + 1) 0 zs ====> go 0 zs
    where foo = (\b x -> b + 1)
          go  = foldl @@@ foo
          i.e. go b []     = b
               go b (x:xs) = go (foo b x) xs

data [a]<p :: a -> a -> Bool> 
  = []
  | (:) (h :: a) (t :: [a<p h>]<p>)  

data (a1, a2) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  , p4 :: a1 -> a2 -> a3 -> a4 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>) (x4 :: a4<p4 x1 x2 x3>)

Get ITE predicates to parse:
{-@ assert drop        :: forall a. n: Int -> xs:[a] -> {v:[a] | (len(xs) <  n) ? (len(v) = 0) : (len(v) = len(xs) - n) } @-}


e1 ? e2 : e3
e1 ? e2 : e3


KNOWN BUGS
----------

- tests/todo/fft.hs

- hmatrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList
    
- xmonad properties

- NDM/catch benchmarks (with refinements)

- cabal integration
    > so you can build against liquid?
    > how does this affect ghc integration? (shouldn't matter, because you
    > can specify --with-ghc

- binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;
