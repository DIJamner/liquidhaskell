GITTERY
-------

- To make local branch goo

    $ git branch foo
    $ git checkout foo
    $ ...
    $ git commit -a -m "did work in foo"

- To send branch to the mothership

    $ git push origin foo

- To work with branch elsewhere

    $ git pull
    $ git checkout foo

MODULESPECS: Load specs from module sources:
--------------------------------------------

see tests/tmp/Moo, Loo, Goo

1. GHC normalizes ALL Names by source module. So

    if A defines foo
    if B re-exports A
    if C imports and uses "foo" from B (even if qualified) 

    then foo is named: A.foo

2. When reading SPEC files, normalize all names by module name:

    module spec A where

    assume foo :: ...
    assume bar :: ...

    Should rename to A.foo, A.bar

    Treat imports just as before -- as long as the names were normalized in
    defining .spec its ok.

3. When reading .HS files,

    - normalize spec by moduleName  {-@ @-}
    - figure out how to transitively read (there is code that transitively
      computes module names to hunt down qual/spec files so piggy back off
      that.

4. Should be possible to then just flatten the qualified specs using the old
   monoid whatsit.

        Bare.qualifySpecByModule :: ModuleName -> Spec -> Spec

   Hook into this at the right place (parser?) and you are set.



    e.g. put GHC.List in the include/GHC/List

         use some function from it, e.g. filter. 



FEATURES 
--------

- Allow qualifiers in HS source via {-@ qualif ... @-} annots (tests/pos/trans.hs)

- re-export specs from module sources:

    e.g. Data.List imports GHC.List and re-exports,

         use some client from Data.List that is actually in GHC.List and
         see that it works. Of course, should be transitive. Yikes.

- redo KMeans with 
    
    getHeads ==> map head
    getTails ==> map tail

- tests/todo/getTails.hs
    the list comprehension versions require TAGs (see coreBinds)
        
        [ h | (h:_) <- xss]

    becomes

        foo []       = []
        foo (tmp:xss) = case tmp of
                         h:_     -> h : foo xss
                         DEFAULT -> foo xss
            
    and we need TAGS to relate len(v) > 0 and DEFAULT...

- Blogging: 
    
    foo.lhs ---- liquid ----> foo.lhs.html (or foo.lhs.md) ----pandoc----> foo.lhs.md.html

  Trick: HsColour only transforms code blocks into HTML, leaves rest untouched.
         Pandoc ignores HTML blocks. #win

- inlining?

    cunning trick with contextual/predicates. (See email)


- Add/Parse predicate signatures for lists<p> and tuples<p> 
  
    e.g. [{x: Int | x > 0}]   <--------- HEREHEREHEREHEREHEREHERE

- pos/deptup.hs (type signature: for constructor wrapper)


data [a]<p :: a -> a -> Bool> 
  = []
  | (:) (h :: a) (t :: [a<p h>]<p>)  

data (a1, a2) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  , p4 :: a1 -> a2 -> a3 -> a4 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>) (x4 :: a4<p4 x1 x2 x3>)

*** Cleanup output (tests/pos/poly0.hs)
    > sexify HsAnnot with Colorized Types? (color refinements blue?) 


*** Data (TyCon) invariants
    3. (CHECK)  generate constraints. 
    4. Add TAG measure (builtin measure)
    
    invariant :: forall a. {v: [a] | (tag(v) = #:)  => len(v) > 0 }
    invariant :: forall a. {v: [a] | (tag(v) = #[]) => len(v) = 0 }
    invariant :: forall a. {v: [a] | (tag(v) = #[] ? len(v) = 0 : len(v) > 0) }
    invariant :: forall a. {v: Map k v | height(v) >= 0 } 

    tags:         #:     #[]

    constant ':'  : Tag 
    constant '[]' : Tag


BENCHMARKS
----------

Paper #1

[OK] GHC.List   (../benchmarks/ghc-7.4.1/List.lhs)
->   Data.List  (../base-4.5.1.0/Data/List.hs)

->   Data.Map
->   Data.Set
->   Data.IntSet
->   Bytestring & Client (Text?)
->   vector-algorithms "vector bounds checking"
     > e.g. "unsafeSlice"
     > maybe only specify types for Vector?
-> Xmonad properties

-> hmatrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList

Paper #2

-> Haskell + DB / Yesod / Snap

- NDM/catch benchmarks (with refinements)


KNOWN BUGS
----------

-> tests/todo/fft.hs

-> binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;
