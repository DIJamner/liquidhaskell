TODO
====

* existentials
* benchmarks: Data.List (foldr)
* predicate-aliases 
* strictness annotations
* self-invariants
* fixpoint profile
* CHECK: how much performance hit from -nosimple?
* benchmarks: Data.Bytestring
* benchmarks: stackset-core
* benchmarks: Data.Text
* tuple-refinements
* get Niki to fix the safe0ZipWith nonsense in PredType.hs

Strictness Annotations
======================

Seem to screw up measures. See tests/pos/maybe000.hs

Self-Invariants
===============

Hack binders to allow things like this:

    invariant z:{v: Maybe {isJust(v) && (v = fromJust(z))}} 

Currently hacked by "copying variables", 

see tests/pos/maybe3.hs [hack which works]
    tests/pos/maybe4.hs [deal with devil which doesn't work]

Predicate Aliases
=================

Then clean up the spec blowup in Map?

         <---------------------- HEREHEREHEREHEREHEREHERE

{-@ maybeGe(lo, v)     = ((isJustS(lo)) => (v >= fromJustS(lo))) @-}
{-@ maybeLe(hi, v)     = ((isJustS(lo)) => (v <= fromJustS(hi))) @-}
{-@ inRange(lo, hi, v) = maybeGe(lo, v) && maybeLe(hi, v)        @-}

inRange(lo, hi, v) = {v:k | (((isJustS(lo)) => (v >= fromJustS(lo))) && (((isJustS(hi)) => (v <= fromJustS(hi)))))} v @-}

Fixpoint Profile
================

-> Where is all the time going in Fixpoint?
    
    liquid ../benchmarks/containers-0.5.0.0/Data/Map/Base.hs

    Solve.acsolve                 280.170 s
      refine                        73.057 s

Tuple Refinements
=================


- Add/Parse predicate signatures for tuples<p>     

> pos/deptup.hs (type signature: for constructor wrapper)

data [a]<p :: a -> a -> Bool> 
  = []
  | (:) (h :: a) (t :: [a<p h>]<p>)  

data (a1, a2) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>)

data (a1, a2, a3) 
  < p1 :: a1 -> Bool
  , p2 :: a1 -> a2 -> Bool
  , p3 :: a1 -> a2 -> a3 -> Bool
  , p4 :: a1 -> a2 -> a3 -> a4 -> Bool
  > 
  = (,) (x1 :: a1<p1>) (x2 :: a2<p2 x1>) (x3 :: a3<p3 x1 x2>) (x4 :: a4<p4 x1 x2 x3>)


Existentials
============

    > also enables cunning trick with contextual/predicates. (See email)

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr op b []     = b
foldr op b (x:xs) = x `op` (foldr f b xs) 

foldr :: (xs:[a] ~> x:a -> b<R(xs)> -> b<R(x:xs)>) -> b<[]> -> zs:[a] -> b<R(zs)>
foldr op b []     = b
foldr op b (x:xs) = op ~xs~ x (foldr f b xs) 

len = foldr (\_ ~xs~ n -> n + 1)


Tags
====

Can we avoid all this and just tweak GHC-Core so it duplicates with the relevant tags?

(and introduce manual measures for the relevant cases.)

So if you have

    case e of
      C1 x1.. -> e1
      C2 x2.. -> e2
      ...
      DEFAULT -> edef

CORE rewrites to:
    case e of
      C1 x1.. -> e1
      C2 x2.. -> e2
      ...
      D1 y1.. -> edef
      D2 y2.. -> edef
      D3 y3.. -> edef

where D1, D2,... are the "missing" constructors of the type for "e".

Only tricky bit is the creation of binders y1... of the relevant type but
easy enough from the GHCType. Also, need not do this in the CORE but can 
just hack cconsE so that it analyzes the DEFAULT case by "splitting on" the
appropriate D1...

How is this transformed?

    case e of
      Bin xxx | cond      -> e
              | otherwise -> t 
      _                   -> t

Next, 

    invariant :: forall a. {v: [a] | (tag(v) = #[] ? len(v) = 0 : len(v) > 0) }

is just,

    invariant :: forall a. {v: [a] | (len(v) >= 0)                       }
    invariant :: forall a. {v: [a] | (isNil(v) ? len(v) = 0 : len(v) > 0)}


(tag(v) = #Bin) => ...

    4. Add TAG measure (builtin measure)
    
    invariant :: forall a. {v: [a] | (tag(v) = #:)  => len(v) > 0 }
    invariant :: forall a. {v: [a] | (tag(v) = #[]) => len(v) = 0 }
    invariant :: forall a. {v: [a] | (tag(v) = #[] ? len(v) = 0 : len(v) > 0) }
    invariant :: forall a. {v: Map k v | height(v) >= 0 } 

    tags:         #:     #[]

    constant ':'  : Tag 
    constant '[]' : Tag

    >  tests/todo/getTails.hs
       the list comprehension versions require TAGs (see coreBinds)
        
        [ h | (h:_) <- xss]

    becomes

        foo []       = []
        foo (tmp:xss) = case tmp of
                         h:_     -> h : foo xss
                         DEFAULT -> foo xss
            
    and we need TAGS to relate len(v) > 0 and DEFAULT...

Blogging 
========

    foo.lhs ---- liquid ----> foo.lhs.html (or foo.lhs.md) ----pandoc----> foo.lhs.md.html

  Trick: HsColour only transforms code blocks into HTML, leaves rest untouched.
         Pandoc ignores HTML blocks. #win



*** Cleanup output (tests/pos/poly0.hs)
    > sexify HsAnnot with Colorized Types? (color refinements blue?) 


    1.  Trivial Stuff (incr, pos, map, fold, etc.)
    2.  Lists I       (append, reverse, map-length, filter)
    3.  Lists II      (take, transpose)
    4.  Lists III     (induction with fold) 
    5.  KMeans        (++ zipWith etc.)
    6.  LambdaEval
    7.  Sorting I     (Insert)
    8.  Sorting II    (Merge, Quick, GHC-wierd-sort)
    9.  Map  I        (BST property, add, delete)
    10. Map II        (Data.Map with elements etc.)
    11. Binary Tree/ Finger Tree?
    12. BDD
    13. Union Find
    14. XMonad I
    15. XMonad II



Paper #1 (Abstract Predicates, ESOP 2013)
=========================================

[OK-PP] Data.KMeans     (Num?, Ord?, Toy-Abs, Toy-$, Toy-Filter)

[OK-PP] List-Sorting    (Order)

[OK-PP] Data.Map        (Order) 
        > ordering
                
[??-PP] http://hackage.haskell.org/packages/archive/llrbtree/0.1.1/doc/html/Data-Set-Splay.html
        > ordering      (Order)

[??-PP] Data.List  (../base-4.5.1.0/Data/List.hs)
        > This needs support for the foldl/foldr business/TAGS
                        (folding)

[??-PP] "Array" initialization/copy etc.
                        (folding)

[??-PP] Xmonad-StackSet-Toy
                        (zippering-??)

Paper #2 (Liquid Types in the Real World, ICFP 2013)
====================================================

[OK]    Data.KMeans

[OK]    GHC.List   (../benchmarks/ghc-7.4.1/List.lhs)

[??-PP] Data.Map (supersedes set)
        > ordering
        > size
        > key-set-properties
        > key-dependence
        > balance (NO)

->   Data.Bytestring & Client 

->   Data.Text (client of bytestring?)
        http://hackage.haskell.org/packages/archive/text/0.11.2.2/doc/html/Data-Text-Lazy-Internal.html
        (See "main invariant")

->   vector/

->   vector-algorithms "vector bounds checking"
     > e.g. "unsafeSlice"
     > maybe only specify types for Vector?

->   xmonad real properties


Other Benchmarks
================

->   hmatrix
     > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
     > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList
->   FingerTrees (containers / Data.Seq)
->   Union-Find (PLDI09 port if necessary?)
->   BDD        (PLDI09 port if necessary?)
->   Bodik's hairy sparse matrix benchmark?


[NO] Data.Set (Map redux)
        > ordering
        > size
        > set-properties
        > balance (NO)

[NO] Data.IntSet
     > tricky bit-level operations/invariants

Paper #2

-> Haskell + DB / Yesod / Snap
-> NDM/catch benchmarks (with refinements)



Known Bugs 
==========

-> tests/todo/fft.hs

-> binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;


Xmonad Case Study
=================

Theorems (from Wouter Swierstra's Coq Development)

    - Invariant: NoDuplicates

    - prop_empty_I      : new  : ? -> {v | invariant(v)} 
    - prop_view_I       : view : ? -> {v | invariant(v)} 
    - prop_greedyView_I : view : ? -> {v | invariant(v)}
    - prop_focusUp_I
    - prop_focusMaster_I
    - prop_focusDown_I 
    - prop_focus_I 
    - prop_insertUp_I
    - prop_delete_I
    - prop_swap_master_I
    - prop_swap_left_I  
    - prop_swap_right_I
    - prop_shift_I 
    - prop_shift_win_I 

[prop_FOO_I] check that various functions outputs satisfy "invariant"

    FOO :: ??? -> {v: StackSet | invariant(v)}

    > Theorem prop_swap_master_I (s : StackSet.stackSet i l a sd) :
    > Theorem prop_view_I (l a sd : Set) (n : nat) (s : StackSet.stackSet nat l a sd) :
    > Theorem prop_greedyView_I (l a sd : Set) (n : nat) (s : StackSet.stackSet nat l a sd) :
    > Theorem prop_focusUp_I (l a sd : Set) (n : nat) (s : StackSet.stackSet nat l a sd) :
    > Theorem prop_focusDown_I (l a sd : Set) (n : nat) (s : StackSet.stackSet nat l a sd) :
    > Theorem prop_focusMaster_I (l a sd : Set) (n : nat) (s : StackSet.stackSet nat l a sd) :
    > Theorem prop_empty_I (m : l) (wids : {wids : list i | wids <> nil}) 
    > Theorem prop_empty (m : l) (wids : {wids : list i | wids <> nil}) 
    > Theorem prop_differentiate (xs : list a) :

[prop_FOO_local] check that various functions preserve a [hidden_spaces] MEASURE 

    FOO :: x: StackSet -> {v: StackSet | hidden_spaces(v) = hidden_spaces(x) }

    > Theorem prop_focus_down_local (s : stackSet i l a sd) :
    > Theorem prop_focus_up_local (s : stackSet i l a sd) : 
    > Theorem prop_focus_master_local (s : stackSet i l a sd) :
    > Theorem prop_delete_local (s : stackSet i l a sd) (eq_dec : forall x y, {x = y} + {x <> y}) :
    > Theorem prop_swap_master_local (s : stackSet i l a sd) : 
    > Theorem prop_swap_left_local (s : stackSet i l a sd) : 
    > Theorem prop_swap_right_local (s : stackSet i l a sd) : 
    > Theorem prop_shift_master_local (s : stackSet i l a sd) : 
    > Theorem prop_insert_local (x : stackSet i l a sd) (eq_dec : forall x y, {x = y} + {x <> y}) :


BAD: these check that: forall x: foo (bar x) == x

    > Theorem prop_focus_right (s : StackSet.stackSet i l a sd) :
    > Theorem prop_focus_left (s : StackSet.stackSet i l a sd) :

[prop_swap_*_focus] check that various functions preserve a [peek] MEASURE
    > Theorem prop_swap_master_focus (x : StackSet.stackSet i l a sd) :
    > Theorem prop_swap_left_focus (x : StackSet.stackSet i l a sd) :
    > Theorem prop_swap_right_focus (x : StackSet.stackSet i l a sd) :


BAD? forall x. swapMaster (swapMaster x) == x 
    > Theorem prop_swap_master_idempotent (x : StackSet.stackSet i l a sd) : 
    
BAD? forall x. view i (view i x) == (view i x)
    > Theorem prop_focusMaster_idem (x : StackSet.stackSet i l a sd) :

    NO. Prove: view :: i -> x -> {v: focus(v) = i}
                    :: i -> x -> {v: focus(x) = i => x = v } 
        
    To prove foo_IDEMPOTENT, find a property P such that:

                foo :: x:t -> {v:t | P(v)}
                foo :: x:t -> {v:t | P(x) => v = x }

SETS: 
    > Theorem prop_screens (s : stackSet i l a sd) :


TRIV/HARD: (function definition)
    > [TRIV]  Theorem prop_screens_work (x : stackSet i l a sd) :
    > Theorem prop_mapWorkspaceId (x : stackSet i l a sd) : 
    > Theorem prop_mapLayoutId (s : stackSet i l a sd) :
    > Theorem prop_mapLayoutInverse (s : stackSet i nat a sd) :
    > Theorem prop_mapWorkspaceInverse (s : stackSet nat l a sd) :

Theorem prop_lookup_current (x : stackSet i l a sd) :
Theorem prop_lookup_visible (x : stackSet i l a sd) : 



GITTERY
=======

- To make local branch goo

    $ git branch foo
    $ git checkout foo
    $ ...
    $ git commit -a -m "did work in foo"

- To send branch to the mothership

    $ git push origin foo

- To work with branch elsewhere

    $ git pull
    $ git checkout foo

SLICE causes problem in neg/ass0.hs, doesn't really help either so may as well nuke, but find bug in fixpoint 




Benchmark Tags
==============

- LIQUIDFAIL : impossible to do verify the spec here

- LIQUIDTODO : possible with some further hacking


