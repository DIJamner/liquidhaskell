

data PredVar = RP !Symbol ![(Symbol, Sort)]     -- NEW

data Refa 
  = RConc !Pred 
  | RKvar !Symbol !Subst
  | RPvar !PredVar !Subst                       -- NEW 
  deriving (Eq, Ord, Data, Typeable)

data Reft = ...                                 -- OLD
data RTyCon a   = ...                           -- OLD
data RAlgRhs a  = ...                           -- OLD
data RDataCon a = ...                           -- OLD
newtype RBind   = ...                           -- OLD
newtype RTyVar  = ...                           -- OLD

data RType a 
  = RVar    !RTyVar     !a
  | RFun    !RBind      !(RType a) !(RType a)
  | RAll    !RTyVar     !(RType a)
  | RConApp !(RTyCon a) ![RType a] ![Reft] !a   -- NEW
  | RClass  !Class      ![RType a]
  | ROther  !Type 
  deriving (Data, Typeable)



refparams: refactor types into RTyCon/RTyConApp @ [RType] [Reft]

    > Change Type Defs
        
        PredVars :: new type for predicate variables (Like KVARS but explicit scope)

        Reft     :: + PVar PredVar Subst
        
        RTyCon   :: as before but all refts/subst happens at params
                    add predicate parameters
                    CHECK: do DataCon fields have names?

        RType    :: - RCon
                    + RConApp RTyCon [RType] [Reft]

    > Change Fun-Wrappers   (fold)
    > Change Subst          (unfold)
        
    > Determine POLARITY of Type-Params, Pred-Params
        newtype Polarity = Pol [Bool]
        
        rTyConTypePolarity :: RTyCon -> Polarity
        rTyConPredPolarity :: RTyCon -> Polarity
            >

    > Change Subtype Splitting using Polarities 
    > Change WF Splitting
    --> rejigger th

0. hack fixpoint, to prevent instantiating ~A with vars of type "func"
1. [] : forall a. [{v:a|false}] and re-enable the set-kvars-to-true.
2. remove explicit "Double" sigs from KMeans0
3. get KMeans to work with WrapType

KNOWN BUGS
----------

- tests/todo/fft.hs

- hmatrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList
    
- xmonad properties

- NDM/catch benchmarks (with refinements)

- cabal integration
    > so you can build against liquid?
    > how does this affect ghc integration? (shouldn't matter, because you
    > can specify --with-ghc

- binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- Dependency between specs
  
  Must include:
    
    {-# ANN module "spec   $LIQUIDHS/List.spec" #-}
  
  Whenever you include:
  
    {-# ANN module "spec   $LIQUIDHS/Vector.spec" #-}

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;
