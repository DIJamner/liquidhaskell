Iffy functions:

- normalizePds 
    > how can recur inside functions and hoist preds out?
    > is it needed if Preds are just refts?

--> Single Grammar for SPEC

-- REFACTORING
-- PrFun x t1 t2 ==> RFun (RB x) t1 t2
-- PrAllPr pv t  ==> RAll (RP pv) t
-- PrAll v t     ==> RAll (RV v) t
-- PrVar v p     ==> RVar (RV v) p
--
--data PrTy a = PrVar     !TyVar     !(Predicate a)
--            | PrLit     !Literal   !(Predicate a)
--      	  | PrAll   !TyVar     !(PrTy a)
--      	  | PrAllPr !(PVar a)  !(PrTy a)
--            | PrClass !Class     ![PrTy a]
--      	  | PrFun   !Symbol    !(PrTy a)   !(PrTy a)
--            | PrTyCon !TC.TyCon  ![PrTy a]   ![(Predicate a)] !(Predicate a)
--            deriving (Data, Typeable)
-- type PrType = PrTy Type


NEXT: Unify Spec Parser Into Workflow As:

B. fix parser to take in BRType (PVar String) (UReft String)

1. Parse Specs Into:
    
        BRType (PVar String) (UReft String)

2. Convert above (via BareM) Into:

        RRType (PVar Type) (UReft Type)

3. Strip above into 

        RRType (PVar Type) Reft                 -- RefType  (assm)
        RRType (PVar Type) (Predicate Type)     -- PrType   (passm)

4. Feed above PrTypes into Predicates.hs to get type-specs

        RRType (PVar Type) (Predicate Type)     -- PrType
       
5. Now CONSGEN:
    
        unify:: PrType -> RefType -> RefType

   Should work as before.

Tidy Annotations
----------------

{-@ data List a << p:a (fld:a) >> = Nil | Cons x:a^True y:List a^p(x) << p(fld)>> -- -}

data List a 
  Nil  :: forall a. List a
  Cons :: forall a. a -> List a -> List a

data Expr a
  Ite    :: forall a. Expr Bool -> Expr a -> Expr a -> Expr a
  Plus   :: Expr Int -> Expr Int -> Expr Int
  ConstI :: Int  -> Expr Int
  ConstB :: Bool -> Expr Bool

data List a 
  = Nil
  | Cons a (List a)

data List a <forall p : a -> a -> Prop, ...>  
  = Nil
  | Cons  (h:a) (List<p> a<p(head)>)

data [a] <forall p : a -> a -> Prop>  
  = [] 
  | (:) (h:a) [a<p(h)>]<p>

data Bst k v <l: k -> k -> Prop, r: k -> k -> Prop>
  = Leaf
  | Node { key   :: k
         , value :: v 
         , left  :: Bst (k<l key>) v <l, r> 
         , right :: Bst (k<r key>) v <l, r>
         }


data Bst k v <forall L :: k -> k -> ? , R :: k -> k -> ?>
  = Leaf
  | Node { key   :: k 
         , val   :: v
         , left  :: Bst<L, R> k<L(key)> v 
         , right :: Bst<L, R> k<R(key)> v
         }

max :: forall a. (Ord a) => a -> a -> a

max :: forall a <p: a -> Prop>. (Ord a) => a<p> -> a<p> -> a<p>

foo :: forall a <p: a -> ?>. (Num a) => a<p> -> a<p> -> a<p>

($) :: (a -> b) -> a -> b

($) :: forall <p :: a -> b -> Prop>. (x:a -> b<p x>) -> y:a -> b<p y>

data Bst k v << p1:k (fld:k) p2:k (fld:k) >> 
  = Empty 
  | Bind { k0 :: k 
         , v0 :: v 
         , l  :: (Bst k^p1(k0) v << p1(fld) p2(fld)>>) 
         , r  :: (Bst k^p2(k0) v << p1(fld) p2(fld)>> ) 
         }

"BST" =  Bst k v <\fld V -> V < fld, \fld V -> V > fld>

data Tup3 a0 a1 a2 <P :: a0 -> a2 -> Prop> 
  = T3 { x0 :: a0
       , x1 :: a1
       , x2 :: {V: a2| P(x0)(V)} 
       }

data Pair k v <P :: k -> k -> Prop> 
  = T3 { x0 :: k
       , x1 :: Bst k v {V: a2| P(x0)(V)} 
       }

data Pair a1 a2 <<P :: a1 -> a2 -> Prop>> 
  = Pair { x1 :: a1,  x2 :: { V : a2 | P(x1)(V) } }
  = Pair { x1 :: a1,  x2 :: a2^P(x1) }


data Pair a b = Pair { x :: a,  y :: b }

C { f1 :: t1    ===> T1 
  , f2 :: t2    ===> T2
  , fn :: tn    ===> Tn
  }

C :: f1:t1 -> f2:t2 -> ... -> fn:tn -> t

Pair :: forall a, b :: x: a -> y: b -> Exists x: a, y: b. Pair a b<x>


data Pair a b =  P { x :: a, y :: b }

data List a   =  Nil | Cons { head :: a, tail :: List a }


let foo = 
  let x :: Int = ...
  let t :: Bst Int String = ...
  (((Pair @ Int) @ Bst Int String) x) t



{V:Int | K1}

Bst {V: Int | K2} {V: String : K3} 



x:a -> b

data Bst k v <L :: k -> k -> Prop, R :: k -> k -> Prop>
  = Leaf
  | Node { key   :: k 
         , val   :: v
         , left  :: Bst {V: k | L(key)(V)} v <L, R>
         , right :: Bst {V: k | R(key)(V)} v <L, R>
         }





Pair Int (Bst Int String)

    Int            ==> {V: Int | K1}
    Bst Int String ==> Bst {V: Int | K2} {V: String | K3}











{-@ data List a << p:a (fld:a) >> = Nil | Cons x:a^True y:List a^p(x) << p(fld)>> -- -}
data List a = Nil | Cons a (List a)

{-@ insert :: (Ord a) => a -> [a]{fld <= V} -> [a]{fld <= V} -}
insert y Nil         = Cons y Nil
insert y (Cons x xs) = if (y<x) 
                        then Cons y (Cons x xs)
                        else Cons x (insert y xs)



Transition to GHC 7.4
---------------------

0. hack fixpoint, to prevent instantiating ~A with vars of type "func"
1. [] : forall a. [{v:a|false}] and re-enable the set-kvars-to-true.
2. remove explicit "Double" sigs from KMeans0
3. get KMeans to work with WrapType

KNOWN BUGS
----------

- tests/todo/fft.hs

- hmatrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList
    
- xmonad properties

- NDM/catch benchmarks (with refinements)

- cabal integration
    > so you can build against liquid?
    > how does this affect ghc integration? (shouldn't matter, because you
    > can specify --with-ghc

- binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- Dependency between specs
  
  Must include:
    
    {-# ANN module "spec   $LIQUIDHS/List.spec" #-}
  
  Whenever you include:
  
    {-# ANN module "spec   $LIQUIDHS/Vector.spec" #-}

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;
