data PredVar = RP !Symbol ![(Symbol, Sort)]     -- NEW

data Refa 
  = RConc !Pred 
  | RKvar !Symbol !Subst
  | RPvar !PredVar !Subst                       -- NEW 
  deriving (Eq, Ord, Data, Typeable)

data Reft = ...                                 -- OLD
data RTyCon a   = ...                           -- OLD
data RAlgRhs a  = ...                           -- OLD
data RDataCon a = ...                           -- OLD
newtype RBind   = ...                           -- OLD
newtype RTyVar  = ...                           -- OLD

data RType a 
  = RVar    !RTyVar     !a
  | RFun    !RBind      !(RType a) !(RType a)
  | RAll    !RTyVar     !(RType a)
  | RConApp !(RTyCon a) ![RType a] ![Reft] !a   -- NEW
  | RClass  !Class      ![RType a]
  | ROther  !Type 
  deriving (Data, Typeable)



refparams: refactor types into RTyCon/RTyConApp @ [RType] [Reft]

    > Change Type Defs
        
        PredVars :: new type for predicate variables (Like KVARS but explicit scope)

        Reft     :: + PVar PredVar Subst
        
        RTyCon   :: as before but all refts/subst happens at params
                    add predicate parameters
                    CHECK: do DataCon fields have names?

        RType    :: - RCon
                    + RConApp RTyCon [RType] [Reft]

    > Change Fun-Wrappers   (fold)
    > Change Subst          (unfold)
        
    > Determine POLARITY of Type-Params, Pred-Params
        newtype Polarity = Pol [Bool]
        
        rTyConTypePolarity :: RTyCon -> Polarity
        rTyConPredPolarity :: RTyCon -> Polarity
            >

    > Change Subtype Splitting using Polarities 
    > Change WF Splitting
    --> rejigger th

Tidy Annotations
----------------

Merge: 

BarePredicate.PrTypeP and Bare.BType ???


1. forall a. (Ord a) => a -> [a] -> [a]

2. forall a. (Ord a) => a -> {v: [a]{fld <= vv} | [true]} -> {v: [a]{fld <= vv} | [true]}

3.           (Ord a) => a -> [a]{fld <= V} -> [a]{fld <= V}



forall a.
:(Ord a)
-> :a
-> :[] 
<< p:aaBz ((fld : aaBz)) >>
 {a} 
{VV : [(fld <= VV)]} VV : [true]
-> [] 
<< p:aaBz ((fld : aaBz)) >>
 {a} 
{VV : [(fld <= VV)]} VV : [(? nonnull([VV]))]

forall a.
:(Ord a)
-> :a
-> :[] 
<< p:aaBz ((fld : aaBz)) >>
 {a} 
{VV : [(fld <= VV)]} VV : [true]
-> [] 
<< p:aaBz ((fld : aaBz)) >>
 {a} 
{VV : [(fld <= VV)]} VV : [(? nonnull([VV]))]





{-@ data List a << p:a (fld:a) >> = Nil | Cons x:a^True y:List a^p(x) << p(fld)>> -- -}

List a <P :: a -> a -> Prop> 
  = Nil 
  | Cons { head :: a, tail :: List {v:a|P(head)(v)} <P> }

Bst k v <L :: k -> k -> Prop, R :: k -> k -> Prop>
  = Leaf
  | Node { key   :: k 
         , val   :: v
         , left  :: Bst {V: k | L(key)(V)} v <L, R>
         , right :: Bst {V: k | R(key)(V)} v <L, R>
         }

data Bst k v << p1:k (fld:k) p2:k (fld:k) >> 
  = Empty 
  | Bind { k0 :: k 
         , v0 :: v 
         , l  :: (Bst k^p1(k0) v << p1(fld) p2(fld)>>) 
         , r  :: (Bst k^p2(k0) v << p1(fld) p2(fld)>> ) 
         }


"BST" =  Bst k v <\fld V -> V < fld, \fld V -> V > fld>

data Tup3 a0 a1 a2 <P :: a0 -> a2 -> Prop> 
  = T3 { x0 :: a0
       , x1 :: a1
       , x2 :: {V: a2| P(x0)(V)} 
       }

data Pair k v <P :: k -> k -> Prop> 
  = T3 { x0 :: k
       , x1 :: Bst k v {V: a2| P(x0)(V)} 
       }

data Pair a1 a2 <<P :: a1 -> a2 -> Prop>> 
  = Pair { x1 :: a1,  x2 :: { V : a2 | P(x1)(V) } }
  = Pair { x1 :: a1,  x2 :: a2^P(x1) }


data Pair a b = Pair { x :: a,  y :: b }

C { f1 :: t1    ===> T1 
  , f2 :: t2    ===> T2
  , fn :: tn    ===> Tn
  }

C :: f1:t1 -> f2:t2 -> ... -> fn:tn -> t

Pair :: forall a, b :: x: a -> y: b -> Exists x: a, y: b. Pair a b<x>


data Pair a b =  P { x :: a, y :: b }

data List a   =  Nil | Cons { head :: a, tail :: List a }


let foo = 
  let x :: Int = ...
  let t :: Bst Int String = ...
  (((Pair @ Int) @ Bst Int String) x) t



{V:Int | K1}

Bst {V: Int | K2} {V: String : K3} 



x:a -> b

data Bst k v <L :: k -> k -> Prop, R :: k -> k -> Prop>
  = Leaf
  | Node { key   :: k 
         , val   :: v
         , left  :: Bst {V: k | L(key)(V)} v <L, R>
         , right :: Bst {V: k | R(key)(V)} v <L, R>
         }





Pair Int (Bst Int String)

    Int            ==> {V: Int | K1}
    Bst Int String ==> Bst {V: Int | K2} {V: String | K3}











{-@ data List a << p:a (fld:a) >> = Nil | Cons x:a^True y:List a^p(x) << p(fld)>> -- -}
data List a = Nil | Cons a (List a)

{-@ insert :: (Ord a) => a -> [a]{fld <= V} -> [a]{fld <= V} -}
insert y Nil         = Cons y Nil
insert y (Cons x xs) = if (y<x) 
                        then Cons y (Cons x xs)
                        else Cons x (insert y xs)



Transition to GHC 7.4
---------------------

<<<<<<< HEAD
>>>>>>> origin/preds
=======
>>>>>>> 3b9a7a75b7c6675975265b6b258ca4a683b72ab4
0. hack fixpoint, to prevent instantiating ~A with vars of type "func"
1. [] : forall a. [{v:a|false}] and re-enable the set-kvars-to-true.
2. remove explicit "Double" sigs from KMeans0
3. get KMeans to work with WrapType

KNOWN BUGS
----------

- tests/todo/fft.hs

- hmatrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Matrix.html#Matrix
    > http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/src/Data-Packed-Internal-Vector.html#fromList
    
- xmonad properties

- NDM/catch benchmarks (with refinements)

- cabal integration
    > so you can build against liquid?
    > how does this affect ghc integration? (shouldn't matter, because you
    > can specify --with-ghc

- binsearch crashes because you have chains like:
        
        x1 = 2
        x2 = x1
        x3 = x2
        z  = x3 / 2

  so I guess you need some constprop inside the constraint simplification.

- Dependency between specs
  
  Must include:
    
    {-# ANN module "spec   $LIQUIDHS/List.spec" #-}
  
  Whenever you include:
  
    {-# ANN module "spec   $LIQUIDHS/Vector.spec" #-}

- tests/pos/data-mono0.hs
  partial pattern match desugars into exception syntax with unhandled
  casts. Throws an error in fixpoint. At least throw error in Constraint Gen?
          (\ _ ->
             (Control.Exception.Base.irrefutPatError
                @ () "pos/data-mono0.hs:8:9-23|(Test.Cons x _)")
             `cast` (UnsafeCo () GHC.Types.Int :: () ~ GHC.Types.Int))
            GHC.Prim.realWorld#;
